{"ast":null,"code":"var _jsxFileName = \"/Users/Josh_Lo/Documents/School/coding_bootcamp_fall_2019/Projects/project-3/client/src/components/Canvas/Canvas.jsx\";\nimport React from 'react';\nexport default class Canvas extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.createObjects = async () => {\n      console.log('creating objects: 1');\n      this.canvas = document.getElementById('canvas');\n      this.context = this.canvas.getContext('2d');\n      this.image = new Image();\n\n      this.image.onload = async () => {\n        console.log('this.canvas', this.canvas);\n        this.context.drawImage(this.image, 0, 0); // const temp = this.image;\n\n        const temp = fetch(this.canvas.toDataURL('image/png', 1)).then(res => {\n          console.log(res);\n          return res.arrayBuffer();\n        }).then(buffer => {\n          console.log(buffer); // console.log(new Uint8Array(buffer));\n\n          return new Uint8ClampedArray(buffer); // Generated array does not have the same byte size as input watdo?\n        }).then(clampedArray => {\n          const image = new ImageData(clampedArray, this.image.width, this.image.height);\n          this.context.putImageData(image, 0, 0); // use putImageData after making changes?\n\n          const imageData = this.context.getImageData(0, 0, this.image.width, this.image.height); // Dimensions are currently hard coded \n\n          console.log('done creating objects: 1', imageData);\n          this.setState({\n            imageData: imageData\n          }, () => {\n            console.log('about to pass imagedata to 2', this.state.imageData);\n          });\n        }).catch(e => {\n          throw e;\n        });\n      };\n\n      this.image.src = this.state.uploadedImage; // Lives at base64 jpeg\n    };\n\n    this.state = {\n      canWidth: this.props.width,\n      canHeight: this.props.height\n    };\n  }\n\n  componentDidMount() {\n    console.log(this.state.canWidth, this.state.canHeight);\n    this.setState({\n      uploadedImage: this.props.uploadedImage,\n      canWidth: this.props.width,\n      canHeight: this.props.height\n    }, () => {\n      let uploadData = new Promise(this.createObjects).then(() => {\n        console.log(uploadData);\n      });\n    });\n  } // THE PROBLEM IS HERE AT THE MOMENT \n  // Lessons learned:\n  // Don't use promises it just makes everything more complicated\n  // getImageData() -> var = imageData.data -> mutate var -> putImageData()\n  // assign this.image.src to a new variable\n  // convert from base64 to uint8\n  // putImageData(uint8)\n  // getImageData\n  // Pass it down\n\n\n  // TODO: Determine majority color and then filter that color out, but for now just do black\n  // async updateImageData() {\n  //     console.log(imageData);\n  //     console.log('Getting uploaded imagedata: 2');\n  //     let pixelIsThere = false;\n  //     for (let i = 0; i < imageData.data.length; i++) {\n  //       console.log(imageData.data[i], imageData.data[i] > 0);\n  //       if (imageData.data[i] !== 0) {\n  //         console.log('found a non zero pixel');\n  //         pixelIsThere = true;\n  //         break;\n  //       }\n  //       if (imageData.data[i] > 0) {\n  //         console.log('holy shit a pixel exists', imageData.data[i]);\n  //         pixelIsThere = true;\n  //         break;\n  //       } else {\n  //         // console.log('nothing is here', imageData.data[i]);\n  //       }\n  //     }\n  //     if (pixelIsThere) {\n  //       console.log('we converted some pixels');\n  //     } else {\n  //       console.log('wtf something is wrong with the input bitmap')\n  //     }\n  //   console.log('returning uploaded imagedata as bitmap: 2');\n  //   return imageData.data; \n  //   // imageData = this.state.imageData;\n  //   // this.context.drawImage(this.image, 0, 0);\n  //   // Gets imagedata as Uint8\n  //   // let imageData = this.context.getImageData(0, 0, this.image.naturalWidth, this.image.naturalHeight);\n  // }\n  // async blackPassFilter() {\n  //   let image = await this.updateImageData();\n  //   this.test1 = image; // Pixel data of uploaded image\n  //   console.log('Passing image bitmap through filter: 3');\n  //   let red, blue, green, alphaVal;\n  //   let numReplace = 0;\n  //   let numTrack = 0;\n  //   // Go through pixel by pixel, check if the pixel rgba value is equal to the track color\n  //   // If not, set rgba to 0, 0, 0, 1 (black);\n  //   for (let i = 0 ; i < image.length; i += 4) {\n  //     red = i;\n  //     blue = i + 1;\n  //     green = i + 2;\n  //     alphaVal = i + 3;\n  //     if (\n  //       ((image[red] < 60) || (image[red] > 66)) &&// Red value\n  //       ((image[blue] < 60) || (image[blue] > 66)) &&// Blue value\n  //       ((image[green] < 60) || (image[green] > 66))  // Green value\n  //       // image[alphaVal] >= 0 // Alpha value\n  //       ) {\n  //         // Currently only modifying the white pixels in the background?\n  //         // console.log('found a non track pixel')\n  //         // console.log('converted colored pixel to white',image[red], image[blue], image[green], image[alphaVal]);\n  //         image[red] = 255;\n  //         image[blue] = 255;\n  //         image[green] = 255;\n  //         image[alphaVal] = 1;\n  //         numReplace++;\n  //       } else if (\n  //         // if num is in between 60 and 65, it's a track pixel\n  //         66 >= image[red] >= 60 &&\n  //         66 >= image[blue] >= 60 &&\n  //         66 >= image[green] >= 60 \n  //         ) {\n  //           // Finds about 23k track pixels\n  //           console.log('found a track pixel');\n  //           numTrack++;\n  //         } else {\n  //           console.log(image[red], image[blue], image[green], image[alphaVal]);\n  //         }\n  //       }\n  //       console.log(numReplace, numTrack);\n  //       this.test2 = image; // Pixel data after looping through\n  //       if (this.test1 === this.test2) {\n  //         console.log('kms');\n  //       }\n  //       let temp = new ImageData(await image, this.image.naturalWidth);\n  //       this.canvas.width = this.image.naturalWidth; this.canvas.height = this.image.naturalHeight;\n  //       void this.context.putImageData(temp, 0, 0);\n  //       console.log('Finished processing image: 3');\n  //       // let imageAsBitmap = await createImageBitmap(temp);\n  //       // console.log('imageAsBitmap', imageAsBitmap);\n  //       return temp;\n  //     }\n  //   setAndDraw = async () => {\n  //     await this.blackPassFilter().then(() => {\n  //       console.log('drawing image for the final time: 4');\n  //       this.context.drawImage(this.image, 0, 0, this.canvas.width, this.canvas.height);\n  //       // this.context.putImageData()\n  //     }); \n  //     console.log('outside of the loop: 4')\n  //   }\n  render() {\n    console.log('rendering canvas');\n    return /*#__PURE__*/React.createElement(\"canvas\", {\n      ref: \"canvas\",\n      id: \"canvas\",\n      width: this.state.canWidth,\n      height: this.state.canHeight,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 190,\n        columnNumber: 9\n      }\n    });\n  }\n\n}","map":{"version":3,"sources":["/Users/Josh_Lo/Documents/School/coding_bootcamp_fall_2019/Projects/project-3/client/src/components/Canvas/Canvas.jsx"],"names":["React","Canvas","Component","constructor","props","createObjects","console","log","canvas","document","getElementById","context","getContext","image","Image","onload","drawImage","temp","fetch","toDataURL","then","res","arrayBuffer","buffer","Uint8ClampedArray","clampedArray","ImageData","width","height","putImageData","imageData","getImageData","setState","state","catch","e","src","uploadedImage","canWidth","canHeight","componentDidMount","uploadData","Promise","render"],"mappings":"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","sourcesContent":["import React from 'react';\n\nexport default class Canvas extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = (\n      {\n        canWidth: this.props.width,\n        canHeight: this.props.height,\n      }\n    );\n  }\n  componentDidMount() {\n    console.log(this.state.canWidth, this.state.canHeight);\n    this.setState(\n      {\n        uploadedImage: this.props.uploadedImage,\n        canWidth: this.props.width,\n        canHeight: this.props.height,\n      }, () => {\n      let uploadData = new Promise(this.createObjects)\n        .then(() => {\n          console.log(uploadData);  \n        });\n      }\n    )\n\n  }\n  // THE PROBLEM IS HERE AT THE MOMENT \n  // Lessons learned:\n    // Don't use promises it just makes everything more complicated\n  // getImageData() -> var = imageData.data -> mutate var -> putImageData()\n  // assign this.image.src to a new variable\n    // convert from base64 to uint8\n    // putImageData(uint8)\n    // getImageData\n    // Pass it down\n  createObjects = async () => {\n    console.log('creating objects: 1');\n    this.canvas = document.getElementById('canvas');\n    this.context = this.canvas.getContext('2d');\n    this.image = new Image();\n    this.image.onload = async () => {\n      console.log('this.canvas', this.canvas);\n      this.context.drawImage(this.image, 0, 0);\n      // const temp = this.image;\n      const temp = fetch(this.canvas.toDataURL('image/png', 1))\n        .then((res) => {\n          console.log(res);\n          return res.arrayBuffer();\n        })\n        .then((buffer) => {\n          console.log(buffer);\n          // console.log(new Uint8Array(buffer));\n          return new Uint8ClampedArray(buffer); // Generated array does not have the same byte size as input watdo?\n        })\n        .then((clampedArray) => {\n          const image = new ImageData(clampedArray, this.image.width, this.image.height);\n          this.context.putImageData(image, 0, 0); // use putImageData after making changes?\n          const imageData = this.context.getImageData(0, 0, this.image.width, this.image.height); // Dimensions are currently hard coded \n          console.log('done creating objects: 1', imageData);\n          this.setState(\n            {\n              imageData: imageData,                  \n            }, () => {\n              console.log('about to pass imagedata to 2', this.state.imageData);\n            }\n          );\n        })\n        .catch((e) => {\n          throw e;\n        })\n      }\n    this.image.src = this.state.uploadedImage; // Lives at base64 jpeg\n  }\n\n  // TODO: Determine majority color and then filter that color out, but for now just do black\n  // async updateImageData() {\n  //     console.log(imageData);\n  //     console.log('Getting uploaded imagedata: 2');\n  //     let pixelIsThere = false;\n  //     for (let i = 0; i < imageData.data.length; i++) {\n  //       console.log(imageData.data[i], imageData.data[i] > 0);\n  //       if (imageData.data[i] !== 0) {\n  //         console.log('found a non zero pixel');\n  //         pixelIsThere = true;\n  //         break;\n  //       }\n  //       if (imageData.data[i] > 0) {\n  //         console.log('holy shit a pixel exists', imageData.data[i]);\n  //         pixelIsThere = true;\n  //         break;\n  //       } else {\n  //         // console.log('nothing is here', imageData.data[i]);\n  //       }\n  //     }\n      \n  //     if (pixelIsThere) {\n  //       console.log('we converted some pixels');\n  //     } else {\n  //       console.log('wtf something is wrong with the input bitmap')\n  //     }\n      \n  //   console.log('returning uploaded imagedata as bitmap: 2');\n  //   return imageData.data; \n  //   // imageData = this.state.imageData;\n  //   // this.context.drawImage(this.image, 0, 0);\n  //   // Gets imagedata as Uint8\n  //   // let imageData = this.context.getImageData(0, 0, this.image.naturalWidth, this.image.naturalHeight);\n  // }\n  \n  // async blackPassFilter() {\n  //   let image = await this.updateImageData();\n  //   this.test1 = image; // Pixel data of uploaded image\n  //   console.log('Passing image bitmap through filter: 3');\n  //   let red, blue, green, alphaVal;\n  //   let numReplace = 0;\n  //   let numTrack = 0;\n  //   // Go through pixel by pixel, check if the pixel rgba value is equal to the track color\n  //   // If not, set rgba to 0, 0, 0, 1 (black);\n  //   for (let i = 0 ; i < image.length; i += 4) {\n  //     red = i;\n  //     blue = i + 1;\n  //     green = i + 2;\n  //     alphaVal = i + 3;\n  //     if (\n  //       ((image[red] < 60) || (image[red] > 66)) &&// Red value\n  //       ((image[blue] < 60) || (image[blue] > 66)) &&// Blue value\n  //       ((image[green] < 60) || (image[green] > 66))  // Green value\n  //       // image[alphaVal] >= 0 // Alpha value\n  //       ) {\n  //         // Currently only modifying the white pixels in the background?\n  //         // console.log('found a non track pixel')\n  //         // console.log('converted colored pixel to white',image[red], image[blue], image[green], image[alphaVal]);\n  //         image[red] = 255;\n  //         image[blue] = 255;\n  //         image[green] = 255;\n  //         image[alphaVal] = 1;\n  //         numReplace++;\n  //       } else if (\n  //         // if num is in between 60 and 65, it's a track pixel\n  //         66 >= image[red] >= 60 &&\n  //         66 >= image[blue] >= 60 &&\n  //         66 >= image[green] >= 60 \n  //         ) {\n  //           // Finds about 23k track pixels\n  //           console.log('found a track pixel');\n  //           numTrack++;\n  //         } else {\n  //           console.log(image[red], image[blue], image[green], image[alphaVal]);\n  //         }\n  //       }\n        \n        \n  //       console.log(numReplace, numTrack);\n        \n  //       this.test2 = image; // Pixel data after looping through\n  //       if (this.test1 === this.test2) {\n  //         console.log('kms');\n  //       }\n  //       let temp = new ImageData(await image, this.image.naturalWidth);\n  //       this.canvas.width = this.image.naturalWidth; this.canvas.height = this.image.naturalHeight;\n        \n  //       void this.context.putImageData(temp, 0, 0);\n        \n  //       console.log('Finished processing image: 3');\n        \n        \n  //       // let imageAsBitmap = await createImageBitmap(temp);\n  //       // console.log('imageAsBitmap', imageAsBitmap);\n  //       return temp;\n  //     }\n      \n  //   setAndDraw = async () => {\n  //     await this.blackPassFilter().then(() => {\n  //       console.log('drawing image for the final time: 4');\n  //       this.context.drawImage(this.image, 0, 0, this.canvas.width, this.canvas.height);\n  //       // this.context.putImageData()\n  //     }); \n  //     console.log('outside of the loop: 4')\n      \n  //   }\n      \n    render() {\n      console.log('rendering canvas');\n\n      \n      return(\n        <canvas ref=\"canvas\" id = \"canvas\" width = {this.state.canWidth} height = {this.state.canHeight}></canvas>\n        )\n      }\n    }\n  "]},"metadata":{},"sourceType":"module"}